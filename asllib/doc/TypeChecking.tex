\chapter{Type System Definitions\label{chap:TypeChecking}}

The purpose of the ASL type system is to describe, in a formal and authoritative way,
which ASL specifications are considered \emph{well-typed}.
Whether a specification is well-typed is defined in terms of a \emph{type system}~\cite{TypeSystemsLucaCardelli}.
That is, a set of \emph{typing rules}.
Typing a specification consists of annotating the root of its AST with the rules defined
in the remainder of this document.

An ASL parser accepts an ASL specification and checks whether it is valid with respect to the syntax of ASL,
which is defined in \secref{ASLGrammar}.
If the specification is syntactically valid, the parser returns an \emph{abstract syntax tree} (AST, for short),
which represents the specification as a labelled structured tree. Otherwise, it returns a syntax error.
When an ASL specification is successfully parsed, we refer to the resulting AST as the \emph{untyped AST}.

A \emph{typechecker} is an implementation of the ASL type system, which accepts an untyped AST and applies the
rules of the type system to the untyped AST. If it is successful, the specification
is considered \emph{well-typed} and the result is a pair consisting of
a \emph{\staticenvironmentterm{}} and a \emph{typed AST},
which are used in defining the ASL semantics (\chapref{Semantics}).
Otherwise, the typechecker returns a \typingerrorterm{}.

\paragraph{Type System Non-determinism:}
We note that the type system is non-deterministic in the following sense:
\begin{itemize}
  \item If a specification is not well-typed due to more than one error, the typechecker
        may return any one of the possible errors. This is because the global declarations
        are processed by applying a topological sort to the dependency graph (see \secref{Dependencies}).
  \item The order of global declarations in the resulting \typedast{} depends on the topological sort
        of the dependency graph (see \secref{Dependencies}), and thus is non-deterministic.
  \item If a specification is well-typed the resulting \typedast{} may contain
        newly generated local storage elements. The identifiers for those elements
        are not in themselves important as they represent temporary values,
        and they are not deterministically determined by the type system.
\end{itemize}

\hypertarget{def-annotaterel}{}
The type system of ASL is given by the relation $\annotaterel$, which is defined as the disjoint union
of the functions and relations defined in this reference.
The functions and relations in this reference are defined, in turn, via type system rules.

Types are represented by respective \typedast{} nodes, derived from the non-terminal $\ty$.
Throughout this document we use $\tty$ to denote a type variable, which should not be confused with the abstract syntax variable $\ty$.

\ChapterOutline
\begin{itemize}
  \item \secref{StaticEnvironments} defines static environments; and
  \item \secref{Typing Rule Configurations} defines the configurations used in typing rules.
\end{itemize}

\section{Static Environments\label{sec:StaticEnvironments}}
A \emph{\staticenvironmentterm{}} (also called a \emph{type environment}) is what the typing rules operate over:
a structure, which amongst other things, associates types to variables.
Intuitively, the typing of a specification makes an initial environment evolve, with new types as given by the
variable declarations of the specification.

\begin{definition}[Static Environment]
Static environments, denoted as $\staticenvs$, \\
are defined as follows (referring to symbols defined by the abstract syntax):
\RenderTypes{static_envs_and_components}

\BackupOriginalType{
\[
\begin{array}{rcl}
\staticenvs 	          &\triangleq& \globalstaticenvs \times \localstaticenvs \\
\\
\globalstaticenvs &\triangleq& \left[
\begin{array}{lcl}
  \declaredtypes        &\mapsto& \Identifier \partialto \ty \times \TPurity\\
  \globalstoragetypes   &\mapsto& \Identifier \partialto \ty \times \globaldeclkeyword,\\
  \exprequiv            &\mapsto& \Identifier \partialto \expr,\\
  \subtypes             &\mapsto& \Identifier \partialto \Identifier,\\
  \subprograms          &\mapsto& \Identifier \partialto \func \times \TSideEffectSet,\\
  \overloadedsubprograms  &\mapsto& \Identifier \partialto \pow{\Strings}
\end{array}
\right]\\
\\
\localstaticenvs &\triangleq& \left[
\begin{array}{lcl}
  \localstoragetypes    &\mapsto& \Identifier \partialto \ty \times \localdeclkeyword,\\
  \exprequiv            &\mapsto& \Identifier \partialto \expr,\\
  \returntype           &\mapsto& \some{ \ty }
\end{array}
\right]\\
\end{array}
\]
}
\end{definition}

We use $\tenv$ and similar variable names (for example, $\tenvone$ and $\newtenv$) to range over static environments.

A \staticenvironmentterm{} $\tenv=(G^\tenv, L^\tenv)$ consists of two
distinct components: the \emph{\globalstaticenvironmentterm} $G^\tenv \in \globalstaticenvs$ --- pertaining to AST nodes
appearing outside of a given subprogram, and the \emph{\localstaticenvironmentterm}
$L^\tenv \in \localstaticenvs$ --- pertaining to AST nodes appearing inside a given subprogram.
This separation allows us to typecheck subprograms by using an empty local environment.

The intuitive meaning of each field appearing above is as follows:
\begin{itemize}
  \hypertarget{def-declaredtypes}{}
  \item $\declaredtypes$ assigns to names of storage elements and enumeration labels their inferred types and \purity{};
  \hypertarget{def-constantvalues}{}
  \item $\constantvalues$ assigns literals to their declaring (global constant) identifiers;
  \hypertarget{def-globalstoragetypes}{}
  \item $\globalstoragetypes$ associates names of global storage elements to their inferred type
  and how they were declared --- as constants, configuration variables, \texttt{let} variables,
  or mutable variables;
  \hypertarget{def-localstoragetypes}{}
  \item $\localstoragetypes$ associates names of local storage elements to their inferred type
  and how they were declared --- as variables, constants, or as \texttt{let} variables;
  \hypertarget{def-exprequiv}{}
  \item $\exprequiv$ associates names of immutable storage elements to a simplified version
  of their initializing expression;
  \hypertarget{def-subtypes}{}
  \item $\subtypes$ associates type names to the names that their type subtypes;
  \hypertarget{def-subprograms}{}
  \item $\subprograms$ associates names of subprograms to the $\func$ AST node they were
  declared with and the set of \sideeffectdescriptorsterm\ inferred for them;
  \hypertarget{def-overloadedsubprograms}{}
  \item $\overloadedsubprograms$ associates names of subprograms to the set of overloading
  subprograms ---  $\func$ AST nodes that share the same name;
  \hypertarget{def-returntype}{}
  \item $\returntype$ contains the name of the type that a subprogram declares, if it is
  a function or a getter.
\end{itemize}

\hypertarget{constant-emptytenv}{}
\begin{definition}[Empty Static Environment]
The \emph{empty \staticenvironmentterm{}}, \\ denoted as $\emptytenv$, is defined as follows:
\[
\emptytenv \triangleq \left(
  \overname{
    \left[
\begin{array}{lcl}
  \declaredtypes        &\mapsto& \emptyfunc,\\
  \constantvalues       &\mapsto& \emptyfunc,\\
  \globalstoragetypes   &\mapsto& \emptyfunc,\\
  \exprequiv            &\mapsto& \emptyfunc,\\
  \subtypes             &\mapsto& \emptyfunc,\\
  \subprograms          &\mapsto& \emptyfunc,\\
  \overloadedsubprograms  &\mapsto& \emptyfunc
\end{array}
\right]}{\globalstaticenvs},
\overname{
 \left[
\begin{array}{lcl}
  \localstoragetypes    &\mapsto& \emptyfunc,\\
  \exprequiv            &\mapsto& \emptyfunc,\\
  \returntype           &\mapsto& \None
\end{array}
\right]}{\localstaticenvs}
\right)
\]
\end{definition}

The global environment and local environment consist of various components.
We use the notation $G^\tenv.m$ and $L^\tenv.m$ to access the $m$ component of a given environment.

To update a function component $f$ (e.g., $\declaredtypes$) of a global or local environment $E$
with a new mapping $x \mapsto v$, we use the notation $\tenv.f[x \mapsto v]$ to stand for $E[f \mapsto E.f[x \mapsto v]]$.

\identd{JRXM} \identi{ZTMQ}

\section{Typing Rule Configurations\label{sec:Typing Rule Configurations}}
The output configurations of type system assertions have two flavors:
\begin{description}
  \item[Normal Outputs.]
  Configurations are typically tuples with different combinations
  of \emph{static environments}, types, and Boolean values.

  \item[Type Errors.] When the type system encounters a \typingerrorterm{},
  for example, using an integer type as a condition expression, as in \verb|if 5 then 1 else 2|,
  the result is a value of the following type:
  \RenderTypes{type_error_and_codes}

  The ASL type system is designed such that when these \emph{\typingerrorterm{} configurations} appear,
  the typing of the entire specification terminates and outputs a \typingerrorterm{} with a code indicating
  the category of error (see \chapref{Errors} for the list of all error codes organized by category).
\end{description}

\BackupOriginalType{
\[
  \typeerror \triangleq \{\TypeErrorVal{\vs} \;|\; \vs \in \Strings \}
\]
}
\hypertarget{type-TypeErrorconfig}{}
We define the shorthand $\TypeErrorConfig \triangleq \TypeError(\vc)$ for \typingerrorterm{} configurations
with any type-error code $\vc \in \typeerrorcode$.

When several \hyperlink{def-caserules}{case rules} for the same function use the same short-circuiting transition assertion,
we do not repeat the\ProseOrTypeError, but rather include it only in the first rule.
